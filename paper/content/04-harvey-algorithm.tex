\chapter{Harvey's algorithm}
\label{chap:harvey}

% \begin{enumerate}
%     \item Brief of the idea;
%     \item Pseudo-algorithm;
%     \item Corretude;
% \end{enumerate}
This chapter presents the probabilistic algorithm proposed by \citet{Harvey:Paper} that finds a perfect matching in general graphs with time complexity \(O(n^\omega)\).

\section{Algorithm}

The main bottleneck in the previous algorithm was the need to update the entire inverse matrix at each step. 
Harvey's algorithm addresses this limitation by employing a divide-and-conquer strategy combined with lazy updates. 
After each recursive step, only the necessary portions of the inverse matrix are updated.
As a result, Harvey's algorithm has a time complexity of \(O(n^\omega)\).

For a graph \(G\) and \(n = |V(G)|\). 
The algorithm maintains two matrices, \(T\) and \(N\), that are initialized as
\begin{enumerate}
    \item \(T \coloneqq \) a Tutte matrix where the entries were randomly chosen\footnote{\cref{sec:prob_tutte}};
    \item \(N \coloneqq T^{-1}\).
\end{enumerate}
It relies on two recursive functions: \(\SC{DeleteEdgesCrossing}\) and \(\SC{DeleteEdgesWithin}\). 

\subsection{\(\SC{DivideInTwo}\)}
\(\SC{DivideInTwo(A)}\) is a function that divides a set \(A\) in two parts, \(R\) and \(S\), such that \(R \cup S = A\), \(R \cap S = \emptyset\) and \(|R| - |S| \leq 1\).
This function has time complexity \(O(n)\) and can be implemented through integer indexing the set.

\subsection{\(\SC{DeleteEdgesCrossing}\)}

$\SC{DeleteEdgesCrossing}(R, S)$: receives two disjoint sets of vertices \(R\) and \(S\) and 
deletes inessential edges that connect a vertex in \(R\) to a vertex in \(S\).
The following invariant must be preserved:
\begin{itemize}
    \item \(\SC{DeleteEdgesCrossing}(R, S)\): initially has \(N_{R \cup S, R \cup S} = {T^{-1}}_{R \cup S, R \cup S}\) and this property is restored after each call 
    of \(\SC{DeleteEdgesCrossing}(R_i, S_j)\).
\end{itemize}
To maintain this invariant the following updates are done. 

\begin{theorem}[Update 1]
\label{update:1}
    Let \(R, S\) be two disjoint sets of vertices such that \(|R| = |S| = 1\).
    Let \(N \coloneqq T^{-1}\), \(r \in R\) and \(s \in S\).
    If \(\{r, s\}\) is inessential, let \(\tilde{T}\) be the Tutte matrix of \(G\) without edge \(\{r, s\}\), then one has
    \[
        \tilde{T}^{-1}_{R, S} = N_{R, S} (1 - T_{R, S} N_{R, S}) / (1 + T_{R, S} N_{R, S})
    \]
    and
    \[
        \tilde{T}^{-1}_{S, R} = N_{S, R} (1 - T_{S, R} N_{S, R}) / (1 + T_{S, R} N_{S, R}) = -\tilde{T}^{-1}_{R, S}.
    \]
\end{theorem}

\begin{proof}
  TODO
%    The inverse of a Tutte Matrix is skew-symmetric, thus \(N_{s, r} = -N_{r, s}\).
%    Let \(V \coloneqq R \cup S\)
%    By \cref{cor:update_cor}, one has:
%    \begin{align*}
%        {T'}^{-1}_{X, X} &= N_{X, X} - N_{X, X} (I + \Delta N_{X, X})^{-1} \Delta N_{X, X} \\
%        &= N_{X, X} - N_{X, X} \bigg(I + \begin{bmatrix} 0 & -T_{r, s} \\ -T_{s, r} & 0 \end{bmatrix} \begin{bmatrix} 0 & N_{r, s} \\ N_{s, r} & 0 \end{bmatrix}\bigg)^{-1} \Delta N_{X, X} \\ &= N_{X, X} - N_{X, X} \bigg(I + \begin{bmatrix} -T_{r, s} N_{s, r} & 0 \\ 0 & -T_{s, r} N_{r, s} \end{bmatrix} \bigg)^{-1} \Delta N_{X, X} \\
%        &= N_{X, X} - N_{X, X} \bigg(I + \begin{bmatrix} T_{r, s} N_{r, s} & 0 \\ 0 & T_{r, s} N_{r, s} \end{bmatrix} \bigg)^{-1} \Delta N_{X, X} \\
%        &= N_{X, X} - N_{X, X} \bigg(\begin{bmatrix} 1 + T_{r, s} N_{r, s} & 0 \\ 0 & 1 + T_{r, s} N_{r, s} \end{bmatrix} \bigg)^{-1} \Delta N_{X, X} \\
%        &= N_{X, X} - N_{X, X} \begin{bmatrix} \frac{1}{1 + T_{r, s} N_{r, s}} & 0 \\ 0 & \frac{1}{1 + T_{r, s} N_{r, s}} \end{bmatrix} \Delta N_{X, X} \\
%        &= N_{X, X} + N_{X, X} \begin{bmatrix} \frac{1}{1 + T_{r, s} N_{r, s}} & 0 \\ 0 & \frac{1}{1 + T_{r, s} N_{r, s}} \end{bmatrix} \begin{bmatrix} T_{r, s} N_{s, r} & 0 \\ 0 & T_{s, r} N_{r, s} \end{bmatrix} \\
%        &= N_{X, X} + N_{X, X} \begin{bmatrix} \frac{T_{r, s}N_{s, r}}{1 + T_{r, s} N_{r, s}} & 0 \\ 0 & \frac{T_{s, r}N_{r, s}}{1 + T_{r, s} N_{r, s}} \end{bmatrix} \\
%        &= N_{X, X} + \begin{bmatrix} 0 & N_{r, s} \\ N_{s, r} & 0 \end{bmatrix} \begin{bmatrix} \frac{T_{s, r}N_{r, s}}{1 + T_{r, s} N_{s, r}} & 0 \\ 0 & \frac{T_{r, s}N_{r, s}}{1 + T_{r, s} N_{r, s}} \end{bmatrix} \\
%        &= N_{X, X} + \begin{bmatrix} 0 & \frac{N_{r, s}T_{s, r}N_{s, r}}{1 + T_{r, s} N_{r, s}} \\ \frac{N_{s, r}T_{r, s}N_{s, r}}{1 + T_{r, s} N_{r, s}} & 0 \end{bmatrix} \\
%        &= \begin{bmatrix} 0 & N_{r, s} + \frac{N_{r, s}T_{s, r}N_{s, r}}{1 + T_{r, s} N_{r, s}} \\ N_{s, r} + \frac{N_{s, r}T_{r, s}N_{s, r}}{1 + T_{r, s} N_{r, s}} & 0 \end{bmatrix} \\ 
%        &= \begin{bmatrix} 0 & \frac{N_{r, s}(1 + T_{r, s}N_{r, s} + T_{s, r}N_{s, r})}{1 + T_{r, s} N_{r, s}} \\ N_{s, r} + \frac{N_{s, r}T_{r, s}N_{s, r}}{1 + T_{r, s} N_{r, s}} & 0 \end{bmatrix} \\ 
%        &= \begin{bmatrix} 0 & \frac{N_{r, s}}{1 + T_{r, s} N_{r, s}} \\ N_{s, r} + \frac{N_{s, r}T_{r, s}N_{s, r}}{1 + T_{r, s} N_{r, s}} & 0 \end{bmatrix}
%    \end{align*}
\end{proof}

\begin{theorem}[Update 2]
\label{update:2}
    Let \(R, S\) be two disjoint set of vertices. Let \(\tilde{T}\) be \(T\) after removing some (possibly zero) edges from \(G\) with an end in \(R_i\) and another in \(S_j\).
    Then, let \(N := T^{-1}\) and \(\Delta := \tilde{T} - T\), one has:
    \[
        {\tilde{T}}^{-1}_{R \cup S, R \cup S} = N_{R \cup S, R \cup S} - N_{R \cup S, R_i \cup S_j}(I + \Delta N_{R_i \cup S_j, R_i \cup S_j})^{-1} \Delta N_{R_i \cup S_j, R \cup S}.
    \]
\end{theorem}

\begin{proof}
    Direct from \cref{cor:update_cor}. Update the whole matrix with \ref{cor:update_cor} and select only the desired submatrix.
\end{proof}

We have the following algorithm.

\begin{programruledcaption}{Harvey's algorithm: \(\SC{DeleteEdgesCrossing}\)}
    \begin{lstlisting}[
      language={pseudocode},
      style=pseudocode,
      style=wider,
      functions={DeleteEdgesCrossing, RemoveEdge, DivideInTwo},
      specialidentifiers={},
    ]
        function DeleteEdgesCrossing(R, S) // R and S are \textbf{disjoint} sets of vertices.
            if $|R| = 0$ or $|S| = 0$ then return // There are no edges.

            if $|R| = 1$ and $|S| = 1$ then // There is at most \textbf{one} edge.
                Let $r$ in $R$
                Let $s$ in $S$
                if $T_{r, s} \neq 0$ \textbf{ and } $N_{r, s} \neq -1 / T_{r, s}$ then // \cref{cor:condition_edge_removal}.
                    $N_{r, s}$ := $N_{r, s} (1 - T_{r, s} N_{r, s}) / (1 + T_{r, s} N_{r, s})$ // \cref{update:1}.
                    $N_{s, r}$ := $-N_{r, s}$
                    RemoveEdge($T, rs$)
                return

            $RS$ := $R \cup S$
            $R_1, R_2$ := DivideInTwo($R$)
            $S_1, S_2$ := DivideInTwo($S$)
            for i \textbf{in} {1, 2} do
                for j \textbf{in} {1, 2} do
                    $T', N'$ := $T, N$ // Save current T and N states
                    DeleteEdgesCrossing($R_i, S_j$)
                    $\Delta$ := $T_{R_i \cup S_j, R_i \cup S_j} - {T'}_{R_i \cup S_j, R_i \cup S_j}$
                    $N_{RS, RS}$ := $N_{RS, RS}' - {N'}_{RS, R_i \cup S_j} (I + \Delta {N'}_{R_i \cup S_j, R_i \cup S_j})^{-1} \Delta {N'}_{R_i \cup S_j, RS}$ // \cref{update:2}.
    \end{lstlisting}
\end{programruledcaption}

\subsubsection{Implementation}
\noindent
The C++ implementation is available at 
\href{https://github.com/antoniomsah/algebraic-max-matching/blob/main/code/algorithms/harvey-algorithm.hpp#L51}{//code/algorithms/harvey-algorithm.hpp:L51}.

\subsubsection{Time complexity}
\noindent
Let \(f(r, s)\) be the running time for \(\SC{DeleteEdgesCrossing}(R, S)\) when \(|R| = r\) and \(|S| = s\).
Let \(n = r + s\). The base cases are \(O(1)\).
Otherwise, a line-by-line analysis:
\begin{enumerate}
    \item \textbf{Dividing in half (Lines 16 and 17)}: Takes \(O(n)\) time;
    \item \textbf{Saving the states (Line 20)}: Takes \(O(n^2)\) time;
    \item \textbf{Recursive call (Line 21)}: Recurrence is \(f(r/2, s/2)\);
    \item \textbf{Delta (Line 22)}: Matrix subtraction is \(O(n^2)\);
    \item \textbf{Update submatrix (Line 23)}: Takes \(O(n^\omega)\).
\end{enumerate}
Combining these steps, we have
\begin{align*}
    f(r, s) &= O(1) + O(1) + O(n^2) + 4(O(n^2) + T(r / 2, s / 2) + O(n^\omega))  \\
    &= 4O(n^2) + 4f(r / 2, s / 2) + 4O(n^\omega) \\
    &= 4f(r / 2, s / 2) + 4O(n^\omega).
\end{align*}
Now, applying the master theorem for recursions, i.e. 
\[
  T(n) = aT(n/b) + f(n).
\]
In this case, \(T(n) = t(r, s)\), \(a = 4\), \(b = 2\) and \(f(n) = O(n^\omega)\), then if \(\omega > \log_{b}a = 2\) the complexity is dominated by \(O(n^\omega)\).
From \cref{matrix:time_complexity}, the best currently known matrix multiplication algorithm has \(\omega > 2\).
Thus, the complexity is dominated by \(O(n^\omega)\) and
\begin{equation}
  \label{alg:delcrossing}
  f(r, s) = 4f(r/2, s/2) + 4O(n^\omega) = 8O(n^\omega) = O(n^\omega). 
\end{equation}

\subsection{\(\SC{DeleteEdgesWithin}\)}

\(\SC{DeleteEdgesWithin}\): receives a set of vertices \(S\) and deletes inessential edges that have both ends in \(S\).
The following invariant must be preserved:
\begin{itemize}
    \item \(\SC{DeleteEdgesWithin}(S)\): initially has \(N_{S, S} = T^{-1}_{S, S}\) and this property is restored after each call of \(\SC{DeleteEdgesWithin}\)
    and \(\SC{DeleteEdgesCrossing}\).
\end{itemize}
To maintain this invariant the following update is done.
\begin{theorem}[Update 3]
\label{update:3}
    Let \(S \subseteq V_G\), \(\tilde{T}\) be \(T\) after removing some (possibly zero) edges from \(G\) with both ends in \(S\).
    Then, let \(N \coloneqq T^{-1}\) and \(\Delta \coloneqq \tilde{T} - T\), one has
    \[
        {\tilde{T}}^{-1}_{S, S} = N_{S, S} - N_{S, S_i}(I + \Delta N_{S_i, S_i})^{-1} \Delta N_{S_i, S}.
    \]
\end{theorem}

\begin{proof}
    Direct from \cref{cor:update_cor}. Update the whole matrix with \ref{cor:update_cor} and select only the desired submatrix.
\end{proof}

We have the following algorithm.

\begin{programruledcaption}{Harvey's algorithm: \(\SC{DeleteEdgesWithin}\)}
    \begin{lstlisting}[
      language={pseudocode},
      style=pseudocode,
      style=wider,
      functions={DeleteEdgesCrossing, DeleteEdgesWithin, DivideInTwo},
      specialidentifiers={},
    ]
        function DeleteEdgesWithin(S)
            if |S| = 1 return

            $S_1, S_2$ := DivideInTwo($S, 2$)
            for i \textbf{in} {1, 2} do
                $T', N'$ := $T, N$ // Save current T and N states
                DeleteEdgesWithin($S_i$)
                $\Delta$ := $T_{S_i, S_i} - {T'}_{S_i, S_i}$
                $N_{S, S}$ := $N' - {N'}_{S, S_i}(I + \Delta {N'}_{S_i, S_i})^{-1} \Delta {N'}_{S_i, S}$ // \cref{update:3}. 
            DeleteEdgesCrossing($S_1, S_2$)
    \end{lstlisting}
\end{programruledcaption}

\subsubsection{Implementation}
\noindent
The C++ implementation is available at 
\href{https://github.com/antoniomsah/algebraic-max-matching/blob/main/code/algorithms/harvey-algorithm.hpp#L18}{//code/algorithms/harvey-algorithm.hpp:L18}.

\subsubsection{Time complexity}
\noindent
Let \(g(n)\) be the running time of \(\SC{DeleteEdgesWithin}(S)\) when \(|S| = n\).
The base case is direct.
Then, through a line-by-line analysis we have
\begin{enumerate}
  \item \textbf{DivideInTwo (Line 4)}: Takes \(O(n)\) times;
  \item \textbf{Saving the states (Line 6)}: Takes \(O(n^2)\) time;
  \item \textbf{Recursive call (Line 7)}: Takes \(g(n/2)\) time;
  \item \textbf{Delta (Line 8)}: Takes \(O(n^2)\);
  \item \textbf{Update 3 (Line 9)}: Takes \(O(n^\omega)\) time;
  \item \textbf{DeleteEdgesCrossing (Line 10)}: Takes \(f(n/2, n/2)\).
\end{enumerate}
Now, combining these steps:
\begin{align*}
    g(n) &= O(n) + 2 (2O(n^2) + g(n / 2) + O(n^\omega)) + f(n/2, n/2) &  \\
    &= O(n) + 2 (2O(n^2) + g(n / 2) + O(n^\omega)) + O(n^\omega) & \text{by \ref{alg:delcrossing}} \\
    &= 2g(n / 2) + 3O(n^\omega).
\end{align*}
Similarly to \cref{alg:delcrossing}, we have
\begin{equation}
\label{alg:delwithin}
  g(n) = 2g(n / 2) + 3O(n^\omega) = O(n^\omega).
\end{equation}

\subsection{\(\SC{PerfectMatching}\)}

\(\SC{PerfectMatching}\): Receives a graph \(G\) and finds a perfect matching, or returns \(\emptyset\) if one does not exist.
It creates a Tutte Matrix of \(G\) with random entries.
Note that calling \(\SC{DeleteEdgesWithin}(V(G))\) is equivalent to deleting every inessential edge from \(G\).
Thus, after this call, the graph only has essential edges, i.e., edges from the perfect matching. 
Consequently, there is the following implementation:

\begin{programruledcaption}{Harvey's algorithm: \(\SC{Perfect Matching}\)}
    \begin{lstlisting}[
      language={pseudocode},
      style=pseudocode,
      style=wider,
      functions={DeleteEdgesWithin},
      specialidentifiers={},
    ]
        function PerfectMatching(G)
            T := $\SC{TutteMatrix}(G)$
            if T \textbf{ is singular} then return $\emptyset$ // The graph has no perfect matching
            N := $T^{-1}$
            DeleteEdgesWithin($V$)
            return $E(T)$
    \end{lstlisting}
\end{programruledcaption}

\subsubsection{Implementation}
\noindent
The C++ implementation is available at 
\href{https://github.com/antoniomsah/algebraic-max-matching/blob/main/code/solver.hpp#L89}{//code/solver.hpp:L89}.

\subsubsection{Time complexity}
\noindent
Let \(T(n)\) be the running time of \(\SC{PerfectMatching(G)}\) when \(|V| = n\). 
A line-by-line comparison:
\begin{enumerate}
  \item \textbf{Building a TutteMatrix (Line 2)}: Takes \(O(n^2)\) time;
  \item \textbf{Checking if a matrix is singular (Line 3)}: Takes \(O(n^\omega)\) time;
  \item \textbf{Calculating a matrix inverse (Line 4)}: Takes \(O(n^\omega)\) time;
  \item \textbf{DeleteEdgesWithin (Line 5)}: From \cref{alg:delwithin}, takes \(g(|V|) = O(n^\omega)\) time;
  \item \textbf{Returning the matching (Line 6)}: Takes \(O(n^2)\) time.
\end{enumerate}
Combining these steps, we have:
\begin{equation}
\label{alg:harvey_complexity}
    T(n) = O(n^2) + O(n^\omega) + O(n^\omega) + O(n^\omega) + O(n^2) = O(n^\omega).
\end{equation}

\subsubsection{Probability of failure}
\noindent
Let \(\delta\) be the probability of failure.
From \cref{lemma:schwartz-zippel}, deciding if an edge can be deleted fails with probability \(n / q\) where \(q\) is the size of the field. 
Since there are \(\binom{n}{2}\) edges, then 
\[
  \delta \leq \binom{n}{2} n / q < n^3 / q.
\]

\subsubsection{Corretude}
\noindent
To prove the algorithm's correctness, it suffices that for every edge \(uv \in E(G)\), when evaluating whether \(uv\) can be removed (using \cref{cor:condition_edge_removal}), one has \(N_{uv} = T^{-1}_{uv}\).
This equality is guaranteed by the invariants.
Since the updates ensure that the invariants are maintained throughout the algorithm, we can conclude that the edge removal decisions are correct.

\section{Analysis}

This section compares Harvey's algorithm with three perfect matching algorithms:
\begin{enumerate}
   \item The simple algorithm presented in \cref{alg:simple};
   \item The rank-two algorithm described in \cref{alg:rank-two};
 \item A graph theory-based implementation used in competitive programming competitions (see \href{https://codeforces.com/blog/entry/92339}{codeforces.com/blog/entry/92339}).
\end{enumerate}
The comparisons are made through random tests together with a verifier that asserts the output is a valid perfect matching.


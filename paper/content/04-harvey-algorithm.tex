\chapter{Harvey's algorithm}

TODO: Introduction.

% \begin{enumerate}
%     \item Brief of the idea;
%     \item Pseudo-algorithm;
%     \item Corretude;
% \end{enumerate}


\section{Algorithm}

The main bottleneck in the previous algorithm was the need to update the entire inverse matrix at each step. 
Harvey's algorithm addresses this limitation by employing a divide-and-conquer strategy combined with lazy updates. 
After each recursive step, only the necessary portions of the inverse matrix are updated.
As a result, Harvey's algorithm has a time complexity of \(O(n^\omega)\).

The algorithm will maintain two matrices: \(T\), a Tutte Matrix of the graph, and \(N\), which is initialized as \(T^{-1}\).
Remember that using Tutte matrices implies that the algorithm is \textbf{probabilistic}\footnote{I want to add a reminder, but I want to explain in the previous section}.
It relies on two recursive functions: \(\SC{DeleteEdgesCrossing}\) and \(\SC{DeleteEdgesWithin}\). 

\subsection{\(\SC{DeleteEdgesCrossing}\)}

$\SC{DeleteEdgesCrossing}(R, S)$: receives two disjoint sets of vertices \(R\) and \(S\) and 
deletes non-essential\footnote{Essential and non-essential edges will be defined in the previous chapter.} 
edges that connect a vertex in \(R\) to a vertex in \(S\).
The following invariant must be preserved:
\begin{itemize}
    \item \(\SC{DeleteEdgesCrossing}(R, S)\): intially has \(N_{R \cup S, R \cup S} = {T^{-1}}_{R \cup S, R \cup S}\) and this property is restored after each call 
    of \(\SC{DeleteEdgesCrossing}(R_i, S_j)\).
\end{itemize}
To maintain this invariant the following updates are done. 

TODO: explicit that in both update theorems \(T\) is a Tutte Matrix.

\begin{theorem}[Update 1]
    Given two disjoint sets \(R\) and \(S\) such that \(|R| = |S| = 1\).
    Let \(N \coloneqq T^{-1}\), \(r \in R\) and \(s \in S\).
    If \(rs\) is non-essential, let \(T'\) be the Tutte matrix of \(G\) without edge \(rs\), then one has
    \[
        {T'}^{-1}_{r, s} = N_{r, s} (1 - T_{r, s} N_{r, s}) / (1 + T_{r, s} N_{r, s})
    \]
    and
    \[
        {T'}^{-1}_{s, r} = N_{s, r} (1 - T_{s, r} N_{s, r}) / (1 + T_{s, r} N_{s, r}) = -{T'}^{-1}_{r, s}.
    \]
\end{theorem}

\begin{proof}
    The inverse of a Tutte Matrix is skew-symmetric, thus \(N_{s, r} = -N_{r, s}\).
    Let \(V \coloneqq R \cup S\)
    By corollary \ref{cor:1}, one has:
    \begin{align}
        {T'}^{-1}_{V, V} &= N_{V, V} - N_{V, V} (I + \Delta N_{V, V})^{-1} \Delta N_{V, V} \\
        &= N_{V, V} - N_{V, V} \bigg(I + \begin{bmatrix} 0 & -T_{r, s} \\ -T_{s, r} & 0 \end{bmatrix} \begin{bmatrix} 0 & N_{r, s} \\ N_{s, r} & 0 \end{bmatrix}\bigg)^{-1} \Delta N_{V, V} \\
        &= N_{V, V} - N_{V, V} \bigg(I + \begin{bmatrix} -T_{r, s} N_{s, r} & 0 \\ 0 & -T_{s, r} N_{r, s} \end{bmatrix} \bigg)^{-1} \Delta N_{V, V} \\
        &= N_{V, V} - N_{V, V} \bigg(I + \begin{bmatrix} T_{r, s} N_{r, s} & 0 \\ 0 & T_{r, s} N_{r, s} \end{bmatrix} \bigg)^{-1} \Delta N_{V, V} \\
        &= N_{V, V} - N_{V, V} \bigg(\begin{bmatrix} 1 + T_{r, s} N_{r, s} & 0 \\ 0 & 1 + T_{r, s} N_{r, s} \end{bmatrix} \bigg)^{-1} \Delta N_{V, V} \\
        &= N_{V, V} - N_{V, V} \begin{bmatrix} \frac{1}{1 + T_{r, s} N_{r, s}} & 0 \\ 0 & \frac{1}{1 + T_{r, s} N_{r, s}} \end{bmatrix} \Delta N_{V, V} \\
        &= N_{V, V} - N_{V, V} \begin{bmatrix} \frac{1}{1 + T_{r, s} N_{r, s}} & 0 \\ 0 & \frac{1}{1 + T_{r, s} N_{r, s}} \end{bmatrix} \begin{bmatrix} T_{r, s} N_{r, s} & 0 \\ 0 & T_{r, s} N_{r, s} \end{bmatrix} \\
        &= N_{V, V} - N_{V, V} \begin{bmatrix} \frac{T_{r, s} N_{r, s}}{1 + T_{r, s} N_{r, s}} & 0 \\ 0 & \frac{T_{r, s} N_{r, s}}{1 + T_{r, s} N_{r, s}} \end{bmatrix} \\
        &= N_{V, V} - \begin{bmatrix} 0 & N_{r, s} \\ N_{s, r} & 0 \end{bmatrix} \begin{bmatrix} \frac{T_{r, s} N_{r, s}}{1 + T_{r, s} N_{r, s}} & 0 \\ 0 & \frac{T_{r, s} N_{r, s}}{1 + T_{r, s} N_{r, s}} \end{bmatrix} \\
        &= N_{V, V} - \begin{bmatrix} 0 & \frac{N_{r, s} T_{r, s} N_{r, s}}{1 + T_{r, s} N_{r, s}} \\ \frac{N_{s, r} T_{r, s} N_{r, s}}{1 + T_{r, s} N_{r, s}} & 0 \end{bmatrix} \\
        &= \begin{bmatrix} 0 & N_{r, s} - \frac{N_{r, s} T_{r, s} N_{r, s}}{1 + T_{r, s} N_{r, s}} \\ N_{s, r} - \frac{N_{s, r} T_{r, s} N_{r, s}}{1 + T_{r, s} N_{r, s}} & 0 \end{bmatrix} 
        = \begin{bmatrix} 0 & N_{r, s} - \frac{N_{r, s} T_{r, s} N_{r, s}}{1 + T_{r, s} N_{r, s}} \\ N_{s, r} - \frac{N_{s, r} T_{r, s} N_{r, s}}{1 + T_{r, s} N_{r, s}} & 0 \end{bmatrix} \\
    \end{align}
\end{proof}

\begin{theorem}[Update 2]
    Given two disjoint sets \(R\) and \(S\). Let \(T'\) be \(T\) after removing some (possibly zero) edges from \(G\) that connects vertices from \(R_i\) to vertices in \(S_j\).
    Then, let \(N := T^{-1}\) and \(\Delta := T' - T\), one has:
    \[
        {T'}^{-1}_{R \cup S, R \cup S} = N_{R \cup S, R \cup S} - N_{R \cup S, R_i \cup S_j}(I + \Delta N_{R_i \cup S_j, R_i \cup S_j})^{-1} \Delta N_{R_i \cup S_j, R \cup S}.
    \]
\end{theorem}

\begin{proof}
    Direct from \ref{cor:1}.
\end{proof}

We have the following algorithm.

\begin{programruledcaption}{Harvey's algorithm: \(\SC{DeleteEdgesCrossing}\)}
    \begin{lstlisting}[
      language={pseudocode},
      style=pseudocode,
      style=wider,
      functions={DeleteEdgesCrossing},
      specialidentifiers={},
    ]
        function DeleteEdgesCrossing(R, S) // R and S are \textbf{disjoint} sets
            if $|R| = 0$ or $|S| = 0$ then return $\emptyset$ // There are no edges

            if $|R| = 1$ and $|S| = 1$ then // There is at most \textbf{one} edge
                r, s := vertex in R, vertex in S
                if $T_{r, s} \neq 0$ \textbf{ and } $T_{r, s} \neq -1 / N_{r, s}$ then // This edge can be removed
                    $N_{r, s}$ := $N_{r, s} (1 - T_{r, s} N_{r, s}) / (1 + T_{r, s} N_{r, s})$ // Update 1
                    $N_{s, r}$ := $-N_{r, s}$
                    $T_{rs}, T_{sr}$ := 0, 0 // Edge has been removed
                end
                return
            end

            $RS$ := $R \cup S$
            $R_1, R_2$ := divide R in two 
            $S_1, S_2$ := divide S in two
            for i \textbf{in} {1, 2} do
                for j \textbf{in} {1, 2} do
                    $T', N'$ := $T, N$ // Save current T and N states
                    DeleteEdgesCrossing($R_i, S_j$)
                    $\Delta$ := $T_{R_i \cup S_j, R_i \cup S_j} - {T'}_{R_i \cup S_j, R_i \cup S_j}$
                    $N_{RS, RS}$ := ${N'}_{RS, RS} - {N'}_{RS, R_i \cup S_j} (I + \Delta {N'}_{R_i \cup S_j, R_i \cup S_j})^{-1} \Delta {N'}_{R_i \cup S_j, RS}$ // Update 2
                end
            end
        end
    \end{lstlisting}
\end{programruledcaption}

\textbf{Time complexity:} Let \(f(r, s)\) be the running time for \(\SC{DeleteEdgesCrossing}(R, S)\) when \(|R| = r\) and \(|S| = s\).
Let \(n = r + s\). Clearly, \(f(r, s) = O(1)\) for either base case;
Otherwise, one has:
\begin{align}
    f(r, s) &= O(r + s) + O(r) + O(s) + 4(2O(n^2) + T(r / 2, s / 2) + O(n^\omega))  \\
    &= 8O(n^2) + f(r / 2, s / 2) + 4O(n^\omega) \\
    &= f(r / 2, s / 2) + O(n^\omega) = 2O(n^\omega) = O(n^\omega). \label{alg:delcrossing}
\end{align}


\subsection{\(\SC{DeleteEdgesWithin}\)}

\(\SC{DeleteEdgesWithin}\): receives a set of vertices \(S\) and deletes non-essential edges that have both ends in \(V\).
The following invariant must be preserved:
\begin{itemize}
    \item \(\SC{DeleteEdgesWithin}(S)\): initially has \(N_{S, S} = T^{-1}_{S, S}\) and this property is restored after each call of \(\SC{DeleteEdgesWithin}\)
    and \(\SC{DeleteEdgesCrossing}\).
\end{itemize}
To maintain this invariant the following update is done.
\begin{theorem}[Update 3]
    Given a set \(S\). Let \(T'\) be \(T\) after removing some (possibly zero) edges from \(G\) that connects vertices from \(V\) to vertices in \(V\).
    Then, let \(N \coloneqq T^{-1}\) and \(\Delta \coloneqq T' - T\), one has
    \[
        {T'}^{-1}_{S, S} = N_{S, S} - N_{S, S_i}(I + \Delta N_{S_i, S_i})^{-1} \Delta N_{S_i, S}.
    \]
\end{theorem}

\begin{proof}
    Direct from \ref{cor:1}.
\end{proof}

We have the following algorithm.

\begin{programruledcaption}{Harvey's algorithm: \(\SC{DeleteEdgesWithin}\)}
    \begin{lstlisting}[
      language={pseudocode},
      style=pseudocode,
      style=wider,
      functions={DeleteEdgesCrossing, DeleteEdgesWithin},
      specialidentifiers={},
    ]
        function DeleteEdgesWithin(S)
            if |S| = 1 return

            $S_1, S_2$ := divide S in the middle
            for i \textbf{in} {1, 2} do
                $T', N'$ := $T, N$ // Save current T and N states
                DeleteEdgesWithin($S_i$)
                $\Delta$ := $T_{S_i, S_i} - {T'}_{S_i, S_i}$
                $N_{S, S}$ := $N' - {N'}_{S, S_i}(I + \Delta {N'}_{S_i, S_i})^{-1} \Delta {N'}_{S_i, S}$ // Update 3
            end
            DeleteEdgesCrossing($S_1, S_2$)
        end
    \end{lstlisting}
\end{programruledcaption}

\textbf{Time complexity:} Let \(g(n)\) be the running time of \(\SC{DeleteEdgesWithin}(S)\) when \(|S| = n\).
The base case is direct.
Then, 
\begin{align}
    g(n) &= O(n) + 2 (2O(n^2) + g(n / 2) + O(n^\omega)) + f(n / 2, n / 2) &  \\
    &= 4O(n^2) + 2g(n / 2) + 2O(n^\omega) + f(n / 2, n / 2) & \\ 
    &= 4O(n^2) + 2g(n / 2) + 2O(n^\omega) + O(n^\omega) & \text{by \ref{alg:delcrossing}} \\ 
    &= 2g(n / 2) + 3O(n^\omega) = O(n^\omega) & \label{alg:delwithin}
\end{align}

\subsection{\(\SC{PerfectMatching}\)}

\(\SC{PerfectMatching}\): Receives a graph \(G\) and finds a perfect matching, or returns \(\emptyset\) if one does not exist.
It creates a tutte matrix of \(G\) using constructor\footnote{I want to properly define a tutte matrix constructor and such in the previous chapter}.
Note that calling \(\SC{DeleteEdgesWithin}(V(G))\) is equivalent to deleting every non-essential edge from \(G\).
Thus, after this call, the graph only has essential edges, i.e., edges from the perfect matching. 
Consequently, there is the following implementation:

\begin{programruledcaption}{Harvey's algorithm: \(\SC{Perfect Matching}\)}
    \begin{lstlisting}[
      language={pseudocode},
      style=pseudocode,
      style=wider,
      functions={DeleteEdgesWithin},
      specialidentifiers={},
    ]
        function PerfectMatching(G)
            T := $\SC{TutteMatrix}(G)$
            if T \textbf{ is singular} then return $\emptyset$ // The graph has no perfect matching
            while true do
                N := $T^{-1}$
                DeleteEdgesWithin($V$)
                M := $\emptyset$
                for uv \textbf{in} E(G) do
                    if $T_{uv} \neq 0$ then M := $M \cup \{uv\}$ // This edge was \textbf{not} removed
                end
                if $2|M| = |V|$ // Matching is perfect
                    return M
                end
            end
        end
    \end{lstlisting}
\end{programruledcaption}

\textbf{Time complexity: } Let \(T(n)\) be the running time of \(\SC{PerfectMatching(G)}\) when \(|V| = n\) and \(E(n)\) be the expected number of iterations
until a perfect matching is found. Then,
\begin{align}
    T(n) &= O(n^2) + O(n^\omega) + E(n)(O(n^\omega) + g(n) + O(n^2) + O(1)) & \\
    &= E(n)(O(n^\omega) + g(n)) &  \\
    &= E(n)(O(n^\omega + O(n^\omega))) & \text{by \ref{alg:delwithin}} \\ 
    &= E(n)O(n^\omega) & 
\end{align}

From section x\footnote{prove probability of failure}, deciding if an edge can be deleted fails with probability \(n / q\) where \(q\) is the size of the field. 
Thus, the algorithm fails with probability \(\delta < n^3 / q\). 

Note that the \textbf{corretude} of the algorithm is direct from updates performed. 

\section{Analysis}

In this section, Harvey's algorithm will be compared with other versions of perfect matching algorithms: the ones implemented in the previous section\footnote{If possible, desired to have Edmonds-Blossoms}.
The comparisons are made through random tests together with a verifier that asserts the output is a valid perfect matching.
